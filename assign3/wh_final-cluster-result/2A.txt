ALGOCHANGE:  inlj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.42..32517.98 rows=125930 width=16) (actual time=5.817..552.138 rows=125000 loops=1)
   Buffers: shared hit=199383 read=1567
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25186 width=12) (actual time=0.037..59.634 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.17 rows=5 width=12) (actual time=0.009..0.015 rows=5 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=199383 read=1026
 Planning time: 18.664 ms
 Execution time: 581.342 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |            681 |        124319 |           346 |        75064
 r       |            541 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.42..52553.35 rows=249796 width=16) (actual time=10.364..797.171 rows=250000 loops=1)
   Buffers: shared hit=323770 read=2590
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25046 width=12) (actual time=0.036..45.409 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.93 rows=10 width=12) (actual time=0.009..0.023 rows=10 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=323770 read=2049
 Planning time: 40.428 ms
 Execution time: 850.518 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           1361 |        248639 |           689 |        75131
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..92594.46 rows=490858 width=16) (actual time=11.782..1237.671 rows=500000 loops=1)
   Buffers: shared hit=572407 read=4636
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=24926 width=12) (actual time=0.032..45.386 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..3.44 rows=20 width=12) (actual time=0.010..0.036 rows=20 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=572407 read=4095
 Planning time: 17.310 ms
 Execution time: 1334.152 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2722 |        497278 |          1374 |        75129
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..172859.80 rows=999240 width=16) (actual time=3.692..2062.161 rows=1000000 loops=1)
   Buffers: shared hit=1069678 read=8731
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=24981 width=12) (actual time=0.032..43.384 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..6.45 rows=40 width=12) (actual time=0.010..0.061 rows=40 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=1069678 read=8190
 Planning time: 40.816 ms
 Execution time: 2227.660 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5446 |        994554 |          2745 |        75124
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..312076.33 rows=2036745 width=16) (actual time=11.116..5158.042 rows=2000000 loops=1)
   Buffers: shared hit=2064223 read=16918 written=1
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25459 width=12) (actual time=0.032..56.661 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..11.38 rows=81 width=12) (actual time=0.015..0.162 rows=80 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=2064223 read=16377 written=1
 Planning time: 25.318 ms
 Execution time: 5527.485 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          10891 |       1989109 |          5487 |        75114
 r       |            541 |             0 |             1 |            0
(2 rows)

ALGOCHANGE:  smj-i
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.71..29421.79 rows=126840 width=16) (actual time=0.067..422.684 rows=125000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=124330 read=1831
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25368 width=12) (actual time=0.032..96.297 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.42..23441.82 rows=500000 width=12) (actual time=0.022..190.375 rows=125001 loops=1)
         Buffers: shared hit=124325 read=1020
 Planning time: 51.249 ms
 Execution time: 449.858 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |            681 |        124322 |           347 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.86..55929.84 rows=251550 width=16) (actual time=0.067..745.585 rows=250000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=248650 read=2853
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25155 width=12) (actual time=0.032..99.501 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.42..47453.30 rows=1000000 width=12) (actual time=0.022..408.247 rows=250001 loops=1)
         Buffers: shared hit=248645 read=2042
 Planning time: 42.529 ms
 Execution time: 798.765 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           1361 |        248642 |           689 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.86..108552.42 rows=499320 width=16) (actual time=0.067..1090.824 rows=500000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=497289 read=4897
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=24966 width=12) (actual time=0.032..73.653 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..95099.51 rows=2000000 width=12) (actual time=0.022..677.588 rows=500001 loops=1)
         Buffers: shared hit=497284 read=4086
 Planning time: 38.731 ms
 Execution time: 1171.678 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           2722 |        497281 |          1372 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=17.65..213736.67 rows=996870 width=16) (actual time=0.068..2040.456 rows=1000000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=994565 read=8987
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25080 width=12) (actual time=0.032..68.397 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..190321.80 rows=4000000 width=12) (actual time=0.022..1372.709 rows=1000001 loops=1)
         Buffers: shared hit=994560 read=8176
 Planning time: 64.320 ms
 Execution time: 2188.011 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           5446 |        994557 |          2738 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.72..424017.59 rows=1984558 width=16) (actual time=0.076..5868.093 rows=2000000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=1989120 read=17164
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25053 width=12) (actual time=0.041..82.431 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..380710.99 rows=8000097 width=12) (actual time=0.022..4393.271 rows=2000001 loops=1)
         Buffers: shared hit=1989115 read=16353
 Planning time: 138.573 ms
 Execution time: 6220.516 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          10891 |       1989112 |          5470 |            4
 r       |            541 |             2 |           276 |            4
(2 rows)

ALGOCHANGE:  smj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=67204.65..71587.38 rows=125525 width=16) (actual time=1151.115..1333.217 rows=125000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=3240, temp read=416 written=1346
   ->  Sort  (cost=63578.92..64828.92 rows=500000 width=12) (actual time=1110.011..1173.109 rows=125001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 10728kB
         Buffers: shared hit=5 read=2701, temp read=416 written=1346
         ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.026..217.438 rows=500000 loops=1)
               Buffers: shared hit=2 read=2701
   ->  Sort  (cost=3625.63..3688.40 rows=25105 width=12) (actual time=41.089..56.661 rows=124996 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25105 width=12) (actual time=0.017..31.462 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 37.638 ms
 Execution time: 1351.721 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           2703 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=135787.79..144568.04 rows=252020 width=16) (actual time=2164.288..2537.298 rows=250000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=5943, temp read=681 written=2691
   ->  Sort  (cost=132154.34..134654.34 rows=1000000 width=12) (actual time=2123.116..2264.184 rows=250001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 21448kB
         Buffers: shared hit=5 read=5404, temp read=681 written=2691
         ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=4.542..421.511 rows=1000000 loops=1)
               Buffers: shared hit=2 read=5404
   ->  Sort  (cost=3633.42..3696.43 rows=25202 width=12) (actual time=41.156..72.342 rows=249991 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25202 width=12) (actual time=0.017..31.546 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 54.575 ms
 Execution time: 2570.937 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |           5406 |             2 |             6 |            1
 r       |            541 |             2 |             4 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=277913.95..295372.55 rows=497260 width=16) (actual time=4242.065..4992.708 rows=500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=11348, temp read=3545 written=7532
   ->  Sort  (cost=274307.69..279307.69 rows=2000000 width=12) (actual time=4200.879..4496.995 rows=500001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 42992kB
         Buffers: shared hit=5 read=10809, temp read=3545 written=7532
         ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=4.671..761.252 rows=2000000 loops=1)
               Buffers: shared hit=2 read=10809
   ->  Sort  (cost=3606.21..3668.37 rows=24863 width=12) (actual time=41.170..104.002 rows=499981 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24863 width=12) (actual time=0.027..31.462 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 52.529 ms
 Execution time: 5056.560 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          10811 |             2 |             6 |            1
 r       |            541 |             2 |             4 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=640610.55..675729.95 rows=1007960 width=16) (actual time=9173.425..10643.211 rows=1000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=22159, temp read=11065 written=19085
   ->  Sort  (cost=636977.37..646977.37 rows=4000000 width=12) (actual time=9132.173..9702.536 rows=1000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 86008kB
         Buffers: shared hit=5 read=21620, temp read=11065 written=19085
         ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=4.529..1456.803 rows=4000000 loops=1)
               Buffers: shared hit=2 read=21620
   ->  Sort  (cost=3633.18..3696.18 rows=25199 width=12) (actual time=41.234..166.015 rows=999961 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25199 width=12) (actual time=0.026..31.593 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 74.943 ms
 Execution time: 10767.175 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          21622 |             2 |             6 |            1
 r       |            541 |             2 |             4 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=1317584.89..1387617.64 rows=2002303 width=16) (actual time=20000.207..22894.765 rows=2000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=43781, temp read=32584 written=48671
   ->  Sort  (cost=1313942.07..1333941.96 rows=7999957 width=12) (actual time=19958.964..21067.389 rows=2000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 172088kB
         Buffers: shared hit=5 read=43242, temp read=32584 written=48671
         ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=4.640..2831.632 rows=8000000 loops=1)
               Buffers: shared hit=2 read=43242
   ->  Sort  (cost=3642.42..3705.71 rows=25314 width=12) (actual time=41.228..290.726 rows=1999921 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25314 width=12) (actual time=0.028..31.604 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 47.644 ms
 Execution time: 23137.258 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          43244 |             2 |             6 |            1
(2 rows)

ALGOCHANGE:  hj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2105.64..16067.19 rows=125855 width=16) (actual time=73.771..593.252 rows=125000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=3247
   ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.028..137.820 rows=500000 loops=1)
         Buffers: shared read=2703
   ->  Hash  (cost=1791.00..1791.00 rows=25171 width=12) (actual time=73.229..73.229 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25171 width=12) (actual time=0.032..54.050 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 22.473 ms
 Execution time: 614.503 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |           2703 |             0 |             1 |            0
 r       |            541 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2102.86..29956.59 rows=244773 width=16) (actual time=79.264..1129.879 rows=250000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=5950
   ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=5.114..291.039 rows=1000000 loops=1)
         Buffers: shared read=5406
   ->  Hash  (cost=1791.00..1791.00 rows=24949 width=12) (actual time=73.540..73.540 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24949 width=12) (actual time=0.030..54.456 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 22.384 ms
 Execution time: 1169.812 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5406 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2100.11..57841.23 rows=493012 width=16) (actual time=76.207..2173.292 rows=500000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=11355
   ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=2.513..582.617 rows=2000000 loops=1)
         Buffers: shared read=10811
   ->  Hash  (cost=1791.00..1791.00 rows=24729 width=12) (actual time=72.978..72.978 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24729 width=12) (actual time=0.032..53.906 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 27.050 ms
 Execution time: 2250.200 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10811 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2099.96..113523.68 rows=980172 width=16) (actual time=75.393..3457.547 rows=1000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=22166
   ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=1.744..937.695 rows=4000000 loops=1)
         Buffers: shared read=21622
   ->  Hash  (cost=1791.00..1791.00 rows=24717 width=12) (actual time=73.012..73.012 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24717 width=12) (actual time=0.039..53.912 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 26.253 ms
 Execution time: 3578.115 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          21622 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2106.09..225514.72 rows=2016549 width=16) (actual time=84.335..6553.182 rows=2000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=43788
   ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=10.334..1758.935 rows=8000000 loops=1)
         Buffers: shared read=43244
   ->  Hash  (cost=1791.00..1791.00 rows=25207 width=12) (actual time=73.188..73.188 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25207 width=12) (actual time=0.036..54.068 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 15.163 ms
 Execution time: 6783.655 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

work_mem;
SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          43244 |             0 |             1 |            0
 r       |            541 |             0 |             1 |            0
(2 rows)

ENDOFFILE__: 
