ALGOCHANGE:  inlj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join  (cost=0.29..168504.02 rows=371698 width=8) (actual time=216.362..3110.518 rows=375000 loops=1)
   Buffers: shared hit=1501574 read=3519
   ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.029..152.808 rows=500000 loops=1)
         Buffers: shared read=2703
   ->  Index Scan using ra_idx on r  (cost=0.29..0.32 rows=1 width=4) (actual time=0.005..0.005 rows=0 loops=500000)
         Index Cond: (a = s.y)
         Filter: (b <= 25000)
         Rows Removed by Filter: 1
         Buffers: shared hit=1501574 read=816
 Planning time: 27.134 ms
 Execution time: 3171.968 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |        499459 |           276 |      1002115
 s       |           2703 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join  (cost=0.29..333673.20 rows=750080 width=8) (actual time=224.704..6072.521 rows=750000 loops=1)
   Buffers: shared hit=3003964 read=6222
   ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=7.208..306.519 rows=1000000 loops=1)
         Buffers: shared read=5406
   ->  Index Scan using ra_idx on r  (cost=0.29..0.32 rows=1 width=4) (actual time=0.005..0.005 rows=0 loops=1000000)
         Index Cond: (a = s.y)
         Filter: (b <= 25000)
         Rows Removed by Filter: 1
         Buffers: shared hit=3003964 read=816
 Planning time: 22.182 ms
 Execution time: 6192.745 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |        999459 |           276 |      2004505
 s       |           5406 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join  (cost=0.29..663986.47 rows=1509253 width=8) (actual time=222.770..11725.800 rows=1500000 loops=1)
   Buffers: shared hit=6008744 read=11627
   ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=5.575..586.140 rows=2000000 loops=1)
         Buffers: shared read=10811
   ->  Index Scan using ra_idx on r  (cost=0.29..0.31 rows=1 width=4) (actual time=0.005..0.005 rows=0 loops=2000000)
         Index Cond: (a = s.y)
         Filter: (b <= 25000)
         Rows Removed by Filter: 1
         Buffers: shared hit=6008744 read=816
 Planning time: 24.842 ms
 Execution time: 11960.045 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          10811 |             0 |             1 |            0
 r       |            541 |       1999459 |           276 |      4009285
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join  (cost=0.29..1324986.88 rows=2990312 width=8) (actual time=224.926..23452.399 rows=3000000 loops=1)
   Buffers: shared hit=12018304 read=22438
   ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=6.076..1175.092 rows=4000000 loops=1)
         Buffers: shared read=21622
   ->  Index Scan using ra_idx on r  (cost=0.29..0.31 rows=1 width=4) (actual time=0.005..0.005 rows=0 loops=4000000)
         Index Cond: (a = s.y)
         Filter: (b <= 25000)
         Rows Removed by Filter: 1
         Buffers: shared hit=12018304 read=816
 Planning time: 26.532 ms
 Execution time: 23920.831 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          21622 |             0 |             1 |            0
 r       |            541 |       3999459 |           276 |      8018845
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join  (cost=0.29..2646585.26 rows=5991244 width=8) (actual time=220.392..46489.834 rows=6000000 loops=1)
   Buffers: shared hit=24037424 read=44060
   ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=3.683..2418.784 rows=8000000 loops=1)
         Buffers: shared read=43244
   ->  Index Scan using ra_idx on r  (cost=0.29..0.31 rows=1 width=4) (actual time=0.004..0.004 rows=0 loops=8000000)
         Index Cond: (a = s.y)
         Filter: (b <= 25000)
         Rows Removed by Filter: 1
         Buffers: shared hit=24037424 read=816
 Planning time: 43.811 ms
 Execution time: 47413.828 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          43244 |             0 |             1 |            0
 r       |            541 |       7999459 |           276 |     16037965
(2 rows)

ALGOCHANGE:  smj-i
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=0.71..30019.26 rows=374604 width=8) (actual time=417.344..922.278 rows=375000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=497308 read=4877
   ->  Index Scan using sy_idx on s  (cost=0.42..23495.89 rows=500000 width=12) (actual time=0.026..543.151 rows=500000 loops=1)
         Buffers: shared hit=497303 read=4066
   ->  Materialize  (cost=0.29..3460.80 rows=25001 width=4) (actual time=0.039..113.813 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25001 width=4) (actual time=0.026..98.391 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 44.985 ms
 Execution time: 974.820 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           2703 |        497299 |          1371 |            5
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=0.72..57103.36 rows=748204 width=8) (actual time=727.181..1744.756 rows=750000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=994605 read=8946
   ->  Index Scan using sy_idx on s  (cost=0.42..47435.28 rows=1000000 width=12) (actual time=0.026..1137.573 rows=1000000 loops=1)
         Buffers: shared hit=994600 read=8135
   ->  Materialize  (cost=0.29..3461.12 rows=25133 width=4) (actual time=0.041..118.601 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25133 width=4) (actual time=0.027..102.559 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 38.613 ms
 Execution time: 1845.994 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |           5406 |        994596 |          2737 |            5
 r       |            541 |             2 |           276 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=0.72..111083.82 rows=1490191 width=8) (actual time=1267.134..3130.657 rows=1500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=1989200 read=17083
   ->  Index Scan using sy_idx on s  (cost=0.43..95139.03 rows=2000000 width=12) (actual time=0.026..2139.708 rows=2000000 loops=1)
         Buffers: shared hit=1989195 read=16272
   ->  Materialize  (cost=0.29..3461.18 rows=25155 width=4) (actual time=0.040..110.061 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25155 width=4) (actual time=0.027..93.496 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 42.832 ms
 Execution time: 3316.401 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |          10811 |       1989191 |          5469 |            5
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=0.72..218414.42 rows=3020813 width=8) (actual time=2049.529..5869.127 rows=3000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=3978348 read=33399
   ->  Index Scan using sy_idx on s  (cost=0.43..190328.33 rows=4000000 width=12) (actual time=0.027..4164.028 rows=4000000 loops=1)
         Buffers: shared hit=3978343 read=32588
   ->  Materialize  (cost=0.29..3460.42 rows=24852 width=4) (actual time=0.040..88.072 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=24852 width=4) (actual time=0.027..73.283 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 52.708 ms
 Execution time: 6240.537 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |          21662 |       3978340 |         10934 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=1.39..434226.67 rows=5989935 width=8) (actual time=5816.203..18965.646 rows=6000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7956686 read=65990
   ->  Index Scan using sy_idx on s  (cost=0.43..380678.49 rows=7999957 width=12) (actual time=0.027..14150.305 rows=8000000 loops=1)
         Buffers: shared hit=7956681 read=65179
   ->  Materialize  (cost=0.29..3461.28 rows=25193 width=4) (actual time=0.040..124.793 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25193 width=4) (actual time=0.027..103.872 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 50.858 ms
 Execution time: 20122.152 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          43324 |       7956678 |         21863 |            4
 r       |            541 |             2 |           276 |            4
(2 rows)

ALGOCHANGE:  smj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=67200.81..71560.88 rows=375992 width=8) (actual time=1280.599..1596.172 rows=375000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=3240, temp read=1346 written=1346
   ->  Sort  (cost=63578.92..64828.92 rows=500000 width=12) (actual time=1120.981..1378.299 rows=500000 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 10728kB
         Buffers: shared hit=5 read=2701, temp read=1346 written=1346
         ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.021..219.452 rows=500000 loops=1)
               Buffers: shared hit=2 read=2701
   ->  Sort  (cost=3621.86..3684.51 rows=25058 width=4) (actual time=38.878..41.849 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25058 width=4) (actual time=0.017..30.000 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 51.168 ms
 Execution time: 1640.592 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           2703 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=135778.08..144439.99 rows=755869 width=8) (actual time=2412.348..3097.020 rows=750000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=5943, temp read=2691 written=2691
   ->  Sort  (cost=132154.34..134654.34 rows=1000000 width=12) (actual time=2130.914..2717.389 rows=1000000 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 21448kB
         Buffers: shared hit=5 read=5404, temp read=2691 written=2691
         ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=4.589..420.884 rows=1000000 loops=1)
               Buffers: shared hit=2 read=5404
   ->  Sort  (cost=3623.71..3686.41 rows=25081 width=4) (actual time=38.976..41.865 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25081 width=4) (actual time=0.017..30.139 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 53.178 ms
 Execution time: 3183.344 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           5406 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=277943.12..295511.22 rows=1495081 width=8) (actual time=4770.310..6141.058 rows=1500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=11348, temp read=7532 written=7532
   ->  Sort  (cost=274307.69..279307.69 rows=2000000 width=12) (actual time=4248.537..5437.014 rows=2000000 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 42992kB
         Buffers: shared hit=5 read=10809, temp read=7532 written=7532
         ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=4.688..754.144 rows=2000000 loops=1)
               Buffers: shared hit=2 read=10809
   ->  Sort  (cost=3635.43..3698.50 rows=25227 width=4) (actual time=39.325..42.512 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25227 width=4) (actual time=0.026..30.221 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 51.044 ms
 Execution time: 6310.183 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          10811 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=640591.21..675566.01 rows=2997711 width=8) (actual time=10147.748..12817.347 rows=3000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=22159, temp read=19085 written=19085
   ->  Sort  (cost=636977.37..646977.37 rows=4000000 width=12) (actual time=9183.761..11468.651 rows=4000000 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 86008kB
         Buffers: shared hit=5 read=21620, temp read=19085 written=19085
         ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=4.672..1465.474 rows=4000000 loops=1)
               Buffers: shared hit=2 read=21620
   ->  Sort  (cost=3613.83..3676.23 rows=24958 width=4) (actual time=38.962..42.181 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24958 width=4) (actual time=0.026..30.134 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 63.560 ms
 Execution time: 13151.102 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          21622 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Merge Anti Join  (cost=1317566.98..1387199.39 rows=6024449 width=8) (actual time=22507.446..27748.089 rows=6000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=43781, temp read=48671 written=48671
   ->  Sort  (cost=1313942.07..1333941.96 rows=7999957 width=12) (actual time=20665.581..25109.878 rows=8000000 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 172088kB
         Buffers: shared hit=5 read=43242, temp read=48671 written=48671
         ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=4.131..3252.172 rows=8000000 loops=1)
               Buffers: shared hit=2 read=43242
   ->  Sort  (cost=3624.91..3687.65 rows=25096 width=4) (actual time=39.211..42.918 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25096 width=4) (actual time=0.027..30.338 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 38.332 ms
 Execution time: 28409.505 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          43244 |             2 |             6 |            1
(2 rows)

ALGOCHANGE:  hj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=2103.40..16033.14 rows=377459 width=8) (actual time=100.615..715.905 rows=375000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=3247
   ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.027..163.154 rows=500000 loops=1)
         Buffers: shared read=2703
   ->  Hash  (cost=1791.00..1791.00 rows=24992 width=4) (actual time=69.606..69.606 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24992 width=4) (actual time=0.030..51.624 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 24.741 ms
 Execution time: 781.993 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2703 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=2103.43..29951.93 rows=751541 width=8) (actual time=110.753..1037.066 rows=750000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=5950
   ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=8.624..257.817 rows=1000000 loops=1)
         Buffers: shared read=5406
   ->  Hash  (cost=1791.00..1791.00 rows=24994 width=4) (actual time=69.944..69.944 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24994 width=4) (actual time=0.032..52.228 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 27.179 ms
 Execution time: 1132.053 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5406 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=2104.62..57732.78 rows=1482200 width=8) (actual time=109.250..1861.396 rows=1500000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=11355
   ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=7.438..478.621 rows=2000000 loops=1)
         Buffers: shared read=10811
   ->  Hash  (cost=1791.00..1791.00 rows=25090 width=4) (actual time=69.687..69.687 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25090 width=4) (actual time=0.032..51.869 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 23.649 ms
 Execution time: 2036.110 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10811 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=2099.64..113483.54 rows=3003662 width=8) (actual time=105.760..3609.338 rows=3000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=22166
   ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=4.239..920.897 rows=4000000 loops=1)
         Buffers: shared read=21622
   ->  Hash  (cost=1791.00..1791.00 rows=24691 width=4) (actual time=69.288..69.288 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24691 width=4) (actual time=0.035..51.570 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 29.021 ms
 Execution time: 3956.035 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          21622 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE NOT EXISTS (SELECT * FROM r WHERE r.a=s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=2104.28..224932.98 rows=6026329 width=8) (actual time=111.513..7119.741 rows=6000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=43788
   ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=9.969..1849.437 rows=8000000 loops=1)
         Buffers: shared read=43244
   ->  Hash  (cost=1791.00..1791.00 rows=25062 width=4) (actual time=69.258..69.258 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25062 width=4) (actual time=0.031..51.631 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 28.561 ms
 Execution time: 7807.425 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          43244 |             0 |             1 |            0
(2 rows)

ENDOFFILE__: 
