ALGOCHANGE:  inlj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=1853.52..32630.98 rows=124894 width=8) (actual time=74.044..642.075 rows=125000 loops=1)
   Buffers: shared hit=199383 read=1567
   ->  HashAggregate  (cost=1853.10..2101.51 rows=24841 width=4) (actual time=69.370..86.760 rows=25000 loops=1)
         Group Key: r.a
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24841 width=4) (actual time=0.032..47.823 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.18 rows=5 width=12) (actual time=0.011..0.018 rows=5 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=199383 read=1026
 Planning time: 24.920 ms
 Execution time: 671.461 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |            681 |        124319 |           346 |        75064
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=1853.99..52851.67 rows=246788 width=8) (actual time=90.110..1318.410 rows=250000 loops=1)
   Buffers: shared hit=323770 read=2590
   ->  HashAggregate  (cost=1853.57..2103.83 rows=25026 width=4) (actual time=69.605..88.179 rows=25000 loops=1)
         Group Key: r.a
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25026 width=4) (actual time=0.034..47.874 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.93 rows=10 width=12) (actual time=0.019..0.042 rows=10 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=323770 read=2049
 Planning time: 30.553 ms
 Execution time: 1372.913 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           1361 |        248639 |           689 |        75131
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=1854.47..93208.68 rows=504986 width=8) (actual time=92.252..2502.176 rows=500000 loops=1)
   Buffers: shared hit=572407 read=4636
   ->  HashAggregate  (cost=1854.04..2106.21 rows=25217 width=4) (actual time=69.496..86.432 rows=25000 loops=1)
         Group Key: r.a
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25217 width=4) (actual time=0.033..47.797 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..3.41 rows=20 width=12) (actual time=0.028..0.086 rows=20 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=572407 read=4095
 Planning time: 23.935 ms
 Execution time: 2587.837 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2722 |        497278 |          1374 |        75129
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=1854.43..173528.72 rows=1005095 width=8) (actual time=85.465..8223.483 rows=1000000 loops=1)
   Buffers: shared hit=1069678 read=8731
   ->  HashAggregate  (cost=1854.00..2106.01 rows=25201 width=4) (actual time=69.883..90.162 rows=25000 loops=1)
         Group Key: r.a
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25201 width=4) (actual time=0.033..48.222 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..6.40 rows=40 width=12) (actual time=0.075..0.306 rows=40 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=1069678 read=8190
 Planning time: 31.028 ms
 Execution time: 8376.867 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5446 |        994554 |          2745 |        75124
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: inlj
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=1854.43..308963.33 rows=1969333 width=8) (actual time=89.913..18523.821 rows=2000000 loops=1)
   Buffers: shared hit=2062819 read=18322
   ->  HashAggregate  (cost=1854.00..2106.01 rows=25201 width=4) (actual time=69.428..90.655 rows=25000 loops=1)
         Group Key: r.a
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25201 width=4) (actual time=0.035..47.757 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..11.40 rows=78 width=12) (actual time=0.148..0.700 rows=80 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=2062819 read=17781
 Planning time: 34.885 ms
 Execution time: 18822.665 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10895 |       1989105 |          6887 |        73714
(2 rows)

ALGOCHANGE:  smj-i
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=1.36..30010.27 rows=125112 width=8) (actual time=0.081..464.816 rows=125000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=124330 read=1831
   ->  Index Scan using sy_idx on s  (cost=0.42..23485.79 rows=500000 width=12) (actual time=0.027..195.289 rows=125001 loops=1)
         Buffers: shared hit=124325 read=1020
   ->  Materialize  (cost=0.29..3461.56 rows=25306 width=4) (actual time=0.038..119.438 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25306 width=4) (actual time=0.027..102.942 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 50.565 ms
 Execution time: 492.799 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |            681 |        124322 |           347 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=1.20..57088.41 rows=248783 width=8) (actual time=0.081..810.270 rows=250000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=248650 read=2853
   ->  Index Scan using sy_idx on s  (cost=0.42..47458.69 rows=1000000 width=12) (actual time=0.026..423.935 rows=250001 loops=1)
         Buffers: shared hit=248645 read=2042
   ->  Materialize  (cost=0.29..3461.13 rows=25135 width=4) (actual time=0.038..119.285 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25135 width=4) (actual time=0.027..102.958 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 48.068 ms
 Execution time: 864.295 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           1361 |        248642 |           689 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=2.62..110984.07 rows=504743 width=8) (actual time=0.080..1298.229 rows=500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=497289 read=4897
   ->  Index Scan using sy_idx on s  (cost=0.43..95093.18 rows=2000000 width=12) (actual time=0.027..777.240 rows=500001 loops=1)
         Buffers: shared hit=497284 read=4086
   ->  Materialize  (cost=0.29..3460.75 rows=24982 width=4) (actual time=0.038..86.069 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=24982 width=4) (actual time=0.026..71.443 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 56.905 ms
 Execution time: 1389.501 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           2722 |        497281 |          1372 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=1.20..218607.06 rows=1027555 width=8) (actual time=0.089..2176.324 rows=1000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=994565 read=8987
   ->  Index Scan using sy_idx on s  (cost=0.43..190318.57 rows=4000000 width=12) (actual time=0.027..1372.836 rows=1000001 loops=1)
         Buffers: shared hit=994560 read=8176
   ->  Materialize  (cost=0.29..3460.34 rows=24817 width=4) (actual time=0.047..83.073 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=24817 width=4) (actual time=0.036..69.341 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 61.277 ms
 Execution time: 2332.809 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |           5446 |        994557 |          2738 |            4
 r       |            541 |             2 |           276 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj-i
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=0.72..433681.32 rows=1976601 width=8) (actual time=0.089..6220.406 rows=2000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=1989120 read=17164
   ->  Index Scan using sy_idx on s  (cost=0.43..380649.69 rows=7999957 width=12) (actual time=0.027..4314.993 rows=2000001 loops=1)
         Buffers: shared hit=1989115 read=16353
   ->  Materialize  (cost=0.29..3460.89 rows=25037 width=4) (actual time=0.038..117.663 rows=25000 loops=1)
         Buffers: shared hit=5 read=811
         ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25037 width=4) (actual time=0.027..98.469 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=5 read=811
 Planning time: 75.375 ms
 Execution time: 6612.413 ms
(13 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |          10891 |       1989112 |          5470 |            4
(2 rows)

ALGOCHANGE:  smj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=67207.39..71565.04 rows=123866 width=8) (actual time=1314.687..1454.930 rows=125000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=3240, temp read=416 written=1346
   ->  Sort  (cost=63578.92..64828.92 rows=500000 width=12) (actual time=1275.395..1338.930 rows=125001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 10728kB
         Buffers: shared hit=5 read=2701, temp read=416 written=1346
         ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.025..245.905 rows=500000 loops=1)
               Buffers: shared hit=2 read=2701
   ->  Sort  (cost=3628.36..3691.21 rows=25139 width=4) (actual time=39.275..42.210 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25139 width=4) (actual time=0.017..30.184 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 56.004 ms
 Execution time: 1473.751 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           2703 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=135776.28..144437.33 rows=244073 width=8) (actual time=2170.779..2451.803 rows=250000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=5943, temp read=681 written=2691
   ->  Sort  (cost=132154.34..134654.34 rows=1000000 width=12) (actual time=2130.881..2273.514 rows=250001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 21448kB
         Buffers: shared hit=5 read=5404, temp read=681 written=2691
         ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=5.208..419.004 rows=1000000 loops=1)
               Buffers: shared hit=2 read=5404
   ->  Sort  (cost=3621.94..3684.59 rows=25059 width=4) (actual time=39.883..42.825 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25059 width=4) (actual time=0.016..31.062 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 56.232 ms
 Execution time: 2485.336 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           5406 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=277938.56..295488.67 rows=513349 width=8) (actual time=4358.039..4917.023 rows=500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=11348, temp read=3545 written=7532
   ->  Sort  (cost=274307.69..279307.69 rows=2000000 width=12) (actual time=4318.039..4616.373 rows=500001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 42992kB
         Buffers: shared hit=5 read=10809, temp read=3545 written=7532
         ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=4.017..758.486 rows=2000000 loops=1)
               Buffers: shared hit=2 read=10809
   ->  Sort  (cost=3630.77..3693.70 rows=25169 width=4) (actual time=39.984..43.261 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25169 width=4) (actual time=0.026..31.088 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 31.624 ms
 Execution time: 4981.479 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          10811 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=640566.10..675352.91 rows=998744 width=8) (actual time=9079.085..10155.200 rows=1000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=22159, temp read=11065 written=19085
   ->  Sort  (cost=636977.37..646977.37 rows=4000000 width=12) (actual time=9038.951..9612.599 rows=1000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 86008kB
         Buffers: shared hit=5 read=21620, temp read=11065 written=19085
         ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=4.495..1429.201 rows=4000000 loops=1)
               Buffers: shared hit=2 read=21620
   ->  Sort  (cost=3588.73..3650.34 rows=24645 width=4) (actual time=40.118..43.718 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24645 width=4) (actual time=0.027..31.060 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 46.698 ms
 Execution time: 10279.728 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          21622 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: smj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Merge Semi Join  (cost=1317551.53..1386438.41 rows=1925858 width=8) (actual time=19985.199..22089.896 rows=2000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=43781, temp read=32584 written=48671
   ->  Sort  (cost=1313942.07..1333941.96 rows=7999957 width=12) (actual time=19945.156..21062.593 rows=2000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 172088kB
         Buffers: shared hit=5 read=43242, temp read=32584 written=48671
         ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=4.427..2803.704 rows=8000000 loops=1)
               Buffers: shared hit=2 read=43242
   ->  Sort  (cost=3609.26..3671.51 rows=24901 width=4) (actual time=40.026..43.783 rows=25000 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24901 width=4) (actual time=0.027..31.082 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 40.429 ms
 Execution time: 22333.207 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          43244 |             2 |             6 |            1
(2 rows)

ALGOCHANGE:  hj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Hash Semi Join  (cost=2108.25..13632.61 rows=131126 width=8) (actual time=70.529..591.251 rows=125000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=3247
   ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.028..147.222 rows=500000 loops=1)
         Buffers: shared read=2703
   ->  Hash  (cost=1791.00..1791.00 rows=25380 width=4) (actual time=69.811..69.811 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25380 width=4) (actual time=0.032..51.909 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 26.350 ms
 Execution time: 612.178 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2703 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Semi Join  (cost=2098.45..24858.12 rows=244995 width=8) (actual time=79.117..1129.862 rows=250000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=5950
   ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=8.501..320.283 rows=1000000 loops=1)
         Buffers: shared read=5406
   ->  Hash  (cost=1791.00..1791.00 rows=24596 width=4) (actual time=69.862..69.862 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24596 width=4) (actual time=0.031..52.255 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 23.922 ms
 Execution time: 1170.945 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |           5406 |             0 |             1 |            0
 r       |            541 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Semi Join  (cost=2107.45..47998.15 rows=512221 width=8) (actual time=78.801..1905.892 rows=500000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=11355
   ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=8.812..553.228 rows=2000000 loops=1)
         Buffers: shared read=10811
   ->  Hash  (cost=1791.00..1791.00 rows=25316 width=4) (actual time=69.259..69.259 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25316 width=4) (actual time=0.032..51.686 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 31.806 ms
 Execution time: 1973.691 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10811 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Semi Join  (cost=2107.25..94157.44 rows=1040489 width=8) (actual time=74.995..3413.559 rows=1000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=22166
   ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=5.047..960.152 rows=4000000 loops=1)
         Buffers: shared read=21622
   ->  Hash  (cost=1791.00..1791.00 rows=25300 width=4) (actual time=69.259..69.259 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25300 width=4) (actual time=0.033..51.742 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 29.760 ms
 Execution time: 3538.278 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          21622 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
ALGO: hj
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT z FROM S WHERE EXISTS (SELECT * FROM r WHERE r.a = s.y AND r.b <= 25000);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Hash Semi Join  (cost=2105.12..184982.97 rows=2007914 width=8) (actual time=77.177..6555.756 rows=2000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=43788
   ->  Seq Scan on s  (cost=0.00..123244.97 rows=8000097 width=12) (actual time=7.001..1884.683 rows=8000000 loops=1)
         Buffers: shared read=43244
   ->  Hash  (cost=1791.00..1791.00 rows=25130 width=4) (actual time=69.437..69.437 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 879kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25130 width=4) (actual time=0.036..51.839 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 27.942 ms
 Execution time: 6793.039 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          43244 |             0 |             1 |            0
(2 rows)

ENDOFFILE__: 
