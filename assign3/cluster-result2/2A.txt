ALGOCHANGE:  inlj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.42..32259.22 rows=121566 width=16) (actual time=5.462..699.004 rows=125000 loops=1)
   Buffers: shared hit=199383 read=1567
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=24734 width=12) (actual time=0.035..58.024 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.18 rows=5 width=12) (actual time=0.009..0.021 rows=5 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=199383 read=1026
 Planning time: 26.148 ms
 Execution time: 726.598 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |            681 |        124319 |           346 |        75064
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.42..52445.32 rows=248970 width=16) (actual time=11.846..851.663 rows=250000 loops=1)
   Buffers: shared hit=323770 read=2590
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=24897 width=12) (actual time=0.036..49.745 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.42..1.93 rows=10 width=12) (actual time=0.010..0.024 rows=10 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=323770 read=2049
 Planning time: 22.037 ms
 Execution time: 904.628 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           1361 |        248639 |           689 |        75131
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..92997.25 rows=504448 width=16) (actual time=8.958..1288.619 rows=500000 loops=1)
   Buffers: shared hit=572407 read=4636
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25318 width=12) (actual time=0.033..44.420 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..3.40 rows=20 width=12) (actual time=0.010..0.038 rows=20 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=572407 read=4095
 Planning time: 18.191 ms
 Execution time: 1378.756 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2722 |        497278 |          1374 |        75129
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..172565.42 rows=996678 width=16) (actual time=4.887..2172.761 rows=1000000 loops=1)
   Buffers: shared hit=1069678 read=8731
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25274 width=12) (actual time=0.036..43.513 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..6.37 rows=39 width=12) (actual time=0.010..0.065 rows=40 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=1069678 read=8190
 Planning time: 44.691 ms
 Execution time: 2329.214 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5446 |        994554 |          2745 |        75124
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
SET work_mem TO 4096;
SET
SET enable_nestloop = on;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.43..310409.82 rows=2019597 width=16) (actual time=14.337..4901.999 rows=2000000 loops=1)
   Buffers: shared hit=2064223 read=16918 written=2
   ->  Seq Scan on r  (cost=0.00..1791.00 rows=25261 width=12) (actual time=0.032..58.978 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared read=541
   ->  Index Scan using sy_idx on s  (cost=0.43..11.42 rows=80 width=12) (actual time=0.014..0.153 rows=80 loops=25000)
         Index Cond: (y = r.a)
         Buffers: shared hit=2064223 read=16377 written=2
 Planning time: 26.948 ms
 Execution time: 5226.721 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10891 |       1989109 |          5487 |        75114
(2 rows)

ALGOCHANGE:  smj-i
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.71..29379.11 rows=125390 width=16) (actual time=0.069..427.982 rows=125000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=124330 read=1831
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25304 width=12) (actual time=0.032..96.328 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.42..23413.80 rows=500000 width=12) (actual time=0.023..192.127 rows=125001 loops=1)
         Buffers: shared hit=124325 read=1020
 Planning time: 54.416 ms
 Execution time: 455.662 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |            681 |        124322 |           347 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.72..55944.61 rows=253690 width=16) (actual time=0.069..766.349 rows=250000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=248650 read=2853
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25369 width=12) (actual time=0.033..98.322 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.42..47447.14 rows=1000000 width=12) (actual time=0.022..424.636 rows=250001 loops=1)
         Buffers: shared hit=248645 read=2042
 Planning time: 61.469 ms
 Execution time: 820.157 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           1361 |        248642 |           689 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=1.77..108623.26 rows=505720 width=16) (actual time=0.069..1233.401 rows=500000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=497289 read=4897
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25286 width=12) (actual time=0.032..73.525 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..95105.10 rows=2000000 width=12) (actual time=0.022..770.649 rows=500001 loops=1)
         Buffers: shared hit=497284 read=4086
 Planning time: 24.568 ms
 Execution time: 1324.380 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           2722 |        497281 |          1372 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=0.72..213779.26 rows=997720 width=16) (actual time=0.069..2243.031 rows=1000000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=994565 read=8987
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=25161 width=12) (actual time=0.033..67.219 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..190345.12 rows=4000000 width=12) (actual time=0.022..1505.728 rows=1000001 loops=1)
         Buffers: shared hit=994560 read=8176
 Planning time: 41.515 ms
 Execution time: 2405.786 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |           5446 |        994557 |          2738 |            4
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = on;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=4.68..423918.05 rows=1973829 width=16) (actual time=0.069..6156.771 rows=2000000 loops=1)
   Merge Cond: (r.a = s.y)
   Buffers: shared hit=1989120 read=17164
   ->  Index Scan using ra_idx on r  (cost=0.29..3398.29 rows=24673 width=12) (actual time=0.033..99.466 rows=25000 loops=1)
         Filter: (b <= 25000)
         Rows Removed by Filter: 75000
         Buffers: shared hit=5 read=811
   ->  Index Scan using sy_idx on s  (cost=0.43..380719.90 rows=7999957 width=12) (actual time=0.022..4511.432 rows=2000001 loops=1)
         Buffers: shared hit=1989115 read=16353
 Planning time: 62.140 ms
 Execution time: 6536.944 ms
(11 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |           276 |            4
 s       |          10891 |       1989112 |          5470 |            4
(2 rows)

ALGOCHANGE:  smj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=67194.12..71536.42 rows=122823 width=16) (actual time=1247.155..1428.235 rows=125000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=3240, temp read=416 written=1346
   ->  Sort  (cost=63578.92..64828.92 rows=500000 width=12) (actual time=1205.756..1267.324 rows=125001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 10728kB
         Buffers: shared hit=5 read=2701, temp read=416 written=1346
         ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.030..244.956 rows=500000 loops=1)
               Buffers: shared hit=2 read=2701
   ->  Sort  (cost=3615.20..3677.64 rows=24975 width=12) (actual time=41.385..56.852 rows=124996 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24975 width=12) (actual time=0.018..31.779 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 45.614 ms
 Execution time: 1446.834 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           2703 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=135763.35..144468.80 rows=247043 width=16) (actual time=2227.566..2675.777 rows=250000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=5943, temp read=681 written=2691
   ->  Sort  (cost=132154.34..134654.34 rows=1000000 width=12) (actual time=2158.540..2325.531 rows=250001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 21448kB
         Buffers: shared hit=5 read=5404, temp read=681 written=2691
         ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=4.711..441.553 rows=1000000 loops=1)
               Buffers: shared hit=2 read=5404
   ->  Sort  (cost=3608.86..3671.10 rows=24896 width=12) (actual time=69.010..107.516 rows=249991 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24896 width=12) (actual time=0.023..52.931 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 44.991 ms
 Execution time: 2715.367 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |           5406 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=277939.02..295491.62 rows=503520 width=16) (actual time=4605.624..5352.760 rows=500000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=11348, temp read=3545 written=7532
   ->  Sort  (cost=274307.69..279307.69 rows=2000000 width=12) (actual time=4556.944..4849.012 rows=500001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 42992kB
         Buffers: shared hit=5 read=10809, temp read=3545 written=7532
         ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=4.656..1034.121 rows=2000000 loops=1)
               Buffers: shared hit=2 read=10809
   ->  Sort  (cost=3631.34..3694.28 rows=25176 width=12) (actual time=48.663..112.179 rows=499981 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25176 width=12) (actual time=0.030..38.870 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 24.234 ms
 Execution time: 5416.207 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          10811 |             2 |             6 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=640592.16..675570.76 rows=998640 width=16) (actual time=9188.214..10650.023 rows=1000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=22159, temp read=11065 written=19085
   ->  Sort  (cost=636977.37..646977.37 rows=4000000 width=12) (actual time=9146.027..9706.461 rows=1000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 86008kB
         Buffers: shared hit=5 read=21620, temp read=11065 written=19085
         ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=4.607..1527.064 rows=4000000 loops=1)
               Buffers: shared hit=2 read=21620
   ->  Sort  (cost=3614.48..3676.89 rows=24966 width=12) (actual time=42.171..170.173 rows=999961 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24966 width=12) (actual time=0.024..32.436 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 47.517 ms
 Execution time: 10775.276 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 s       |          21622 |             2 |             6 |            1
 r       |            541 |             2 |             4 |            1
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = on;
SET
SET enable_hashjoin = off;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=1317582.97..1387506.77 rows=1994961 width=16) (actual time=19647.990..22524.727 rows=2000000 loops=1)
   Merge Cond: (s.y = r.a)
   Buffers: shared hit=7 read=43781, temp read=32584 written=48671
   ->  Sort  (cost=1313942.07..1333941.96 rows=7999957 width=12) (actual time=19605.876..20692.302 rows=2000001 loops=1)
         Sort Key: s.y
         Sort Method: external merge  Disk: 172088kB
         Buffers: shared hit=5 read=43242, temp read=32584 written=48671
         ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=6.696..2890.849 rows=8000000 loops=1)
               Buffers: shared hit=2 read=43242
   ->  Sort  (cost=3640.89..3704.13 rows=25295 width=12) (actual time=42.097..297.059 rows=1999921 loops=1)
         Sort Key: r.a
         Sort Method: quicksort  Memory: 2136kB
         Buffers: shared hit=2 read=539
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25295 width=12) (actual time=0.031..32.398 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared hit=2 read=539
 Planning time: 32.417 ms
 Execution time: 22767.864 ms
(19 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             2 |             4 |            1
 s       |          43244 |             2 |             6 |            1
(2 rows)

ALGOCHANGE:  hj
Number of tuples in relation R = 100000
Join factor = 5
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 5)) AS temp(x);
SELECT 500000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  5
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2104.05..16059.25 rows=125220 width=16) (actual time=75.275..638.537 rows=125000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=3247
   ->  Seq Scan on s  (cost=0.00..7703.00 rows=500000 width=12) (actual time=0.029..147.203 rows=500000 loops=1)
         Buffers: shared read=2703
   ->  Hash  (cost=1791.00..1791.00 rows=25044 width=12) (actual time=74.498..74.498 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25044 width=12) (actual time=0.034..55.502 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 36.107 ms
 Execution time: 659.582 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           2703 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 10
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 10)) AS temp(x);
SELECT 1000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  10
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2102.71..29967.01 rows=245830 width=16) (actual time=81.698..1163.947 rows=250000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=5950
   ->  Seq Scan on s  (cost=0.00..15406.00 rows=1000000 width=12) (actual time=6.790..297.025 rows=1000000 loops=1)
         Buffers: shared read=5406
   ->  Hash  (cost=1791.00..1791.00 rows=24937 width=12) (actual time=74.102..74.102 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24937 width=12) (actual time=0.031..54.855 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 26.824 ms
 Execution time: 1203.826 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |           5406 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 20
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 20)) AS temp(x);
SELECT 2000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  20
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2101.20..57784.10 rows=487190 width=16) (actual time=77.851..2162.396 rows=500000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=11355
   ->  Seq Scan on s  (cost=0.00..30811.00 rows=2000000 width=12) (actual time=3.769..568.408 rows=2000000 loops=1)
         Buffers: shared read=10811
   ->  Hash  (cost=1791.00..1791.00 rows=24816 width=12) (actual time=73.334..73.334 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24816 width=12) (actual time=0.032..54.306 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 22.347 ms
 Execution time: 2237.112 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          10811 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 40
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 40)) AS temp(x);
SELECT 4000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  40
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2103.29..113648.63 rows=992334 width=16) (actual time=63.977..3270.425 rows=1000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=22166
   ->  Seq Scan on s  (cost=0.00..61622.00 rows=4000000 width=12) (actual time=7.130..848.450 rows=4000000 loops=1)
         Buffers: shared read=21622
   ->  Hash  (cost=1791.00..1791.00 rows=24983 width=12) (actual time=56.288..56.288 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=24983 width=12) (actual time=0.028..40.857 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 30.745 ms
 Execution time: 3383.279 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          21622 |             0 |             1 |            0
(2 rows)

Number of tuples in relation R = 100000
Join factor = 80
Running psql to load data ...
DROP INDEX IF EXISTS ra_idx;
DROP INDEX
DROP INDEX IF EXISTS sy_idx;
DROP INDEX
DROP TABLE IF EXISTS r;
DROP TABLE
DROP TABLE IF EXISTS s;
DROP TABLE
SELECT a, a AS b, trunc(random() * 1000000) as c  INTO r FROM (SELECT * FROM generate_series(1,100000)) AS temp(a);
SELECT 100000
SELECT x, (x % 100000) + 1 AS y, trunc(random() * 1000000) as z INTO s FROM (SELECT * FROM generate_series(1, 100000 * 80)) AS temp(x);
SELECT 8000000
CREATE INDEX ra_idx ON r (a);
CREATE INDEX
CREATE INDEX sy_idx ON s (y);
CREATE INDEX
VACUUM ANALYZE;
VACUUM
Flushing page cache, dentries and inodes...
Done flushing.
PARAMS:  80
SET work_mem TO 4096;
SET
SET enable_nestloop = off;
SET
SET enable_indexscan = off;
SET
SET enable_mergejoin = off;
SET
SET enable_hashjoin = on;
SET
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT dropdbbuffers('assign3');
 dropdbbuffers 
---------------
 t
(1 row)

EXPLAIN (ANALYZE, BUFFERS) SELECT r.c, s.z FROM r JOIN s ON r.a = s.y WHERE r.b <= 25000;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=2104.64..224917.34 rows=1956956 width=16) (actual time=81.237..6341.417 rows=2000000 loops=1)
   Hash Cond: (s.y = r.a)
   Buffers: shared read=43788
   ->  Seq Scan on s  (cost=0.00..123243.57 rows=7999957 width=12) (actual time=7.085..1644.246 rows=8000000 loops=1)
         Buffers: shared read=43244
   ->  Hash  (cost=1791.00..1791.00 rows=25091 width=12) (actual time=73.426..73.426 rows=25000 loops=1)
         Buckets: 4096  Batches: 1  Memory Usage: 1075kB
         Buffers: shared read=541
         ->  Seq Scan on r  (cost=0.00..1791.00 rows=25091 width=12) (actual time=0.040..54.381 rows=25000 loops=1)
               Filter: (b <= 25000)
               Rows Removed by Filter: 75000
               Buffers: shared read=541
 Planning time: 24.653 ms
 Execution time: 6558.844 ms
(14 rows)

SELECT pg_sleep(2);
 pg_sleep 
----------
 
(1 row)

SELECT relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit FROM pg_statio_all_tables WHERE relname IN ('r', 's');
 relname | heap_blks_read | heap_blks_hit | idx_blks_read | idx_blks_hit 
---------+----------------+---------------+---------------+--------------
 r       |            541 |             0 |             1 |            0
 s       |          43244 |             0 |             1 |            0
(2 rows)

ENDOFFILE__: 
